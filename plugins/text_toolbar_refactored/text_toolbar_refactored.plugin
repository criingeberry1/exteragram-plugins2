from typing import Callable, Dict, List, Optional, Union

from android.content import Context
from android.graphics import PorterDuff, PorterDuffColorFilter, Typeface
from android.text import SpannableStringBuilder
from android.util import TypedValue
from android.view import Gravity, View
from android.widget import (FrameLayout, HorizontalScrollView, ImageView,
                            LinearLayout, TextView)
from android_utils import log as logcat
from base_plugin import BasePlugin, MethodHook
from client_utils import get_last_fragment
from hook_utils import get_private_field
from java import dynamic_proxy
from java.lang import Boolean, Integer, Long, Runnable
from org.telegram.messenger import AndroidUtilities, Emoji, UserConfig
from org.telegram.ui.ActionBar import Theme, ThemeColors
from org.telegram.ui.Components import (AnimatedEmojiDrawable,
                                        AnimatedEmojiSpan,
                                        ChatActivityEnterView, LayoutHelper)
from org.telegram.ui.Stories import PeerStoriesView
from org.telegram.ui import ChatActivity
from org.telegram.ui.Stories.recorder import CaptionContainerView
from ui.bulletin import BulletinHelper
from ui.settings import Selector
from java import jfloat, dynamic_proxy

# --- Ð¼ÐµÑ‚Ð°Ð´Ð°Ð½Ð½Ñ‹Ðµ ---
__id__ = "text_toolbar_refactored"
__name__ = "Text Toolbar Refactored"
__description__ = """
â˜… | Based on original code by @PESSDES_Plugins. 
Adds a customizable text toolbar to the message input field, providing quick access to formatting, text management, and message control tools.
"""
__author__ = "@PESSDES_Plugins | @insonniiia"
__version__ = "1.0.0"
__icon__ = "VoiceToText7/14"
__min_version__ = "11.12.0"


BounceableImageView = CaptionContainerView.BounceableImageView
  
def log(m):
    logcat(f'[text_toolbar] {m}')
 
HIDDEN = 0
COLLAPSED = 1
EXPANDED = 2
VISIBLE = 2

SINGLE_SET = [HIDDEN, VISIBLE]
SET = [HIDDEN, COLLAPSED, VISIBLE]

class Plugin(BasePlugin):
    buttons = {
        30: ("Ð Ð°ÑÑ‚ÑÐ½ÑƒÑ‚ÑŒ Ð½Ð° Ð²ÐµÑÑŒ ÑÐºÑ€Ð°Ð½", SINGLE_SET, "pip_video_expand"),
        0: ("Ð£Ð¿Ð¾Ð¼ÑÐ½ÑƒÑ‚ÑŒ", SINGLE_SET, "mentionbutton"),
        10: ("Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ", SET, "msg_text_outlined"),
        20: ("Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð¼", SET, "msg_edit"),
        60: ("ÐÐµÐ´Ð°Ð²Ð½Ð¸Ðµ ÑÐ¼Ð¾Ð´Ð·Ð¸", SET, "input_smile"),
        40: ("ÐŸÐ¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ", SINGLE_SET, "msg_retry"),
        50: ("Ð¡ÐºÑ€Ñ‹Ñ‚ÑŒ ÐºÐ»Ð°Ð²Ð¸Ð°Ñ‚ÑƒÑ€Ñƒ", SINGLE_SET, "input_keyboard")
    }

    sets = {
        HIDDEN: "Ð¡ÐºÑ€Ñ‹Ñ‚ÑŒ",
        COLLAPSED: "Ð¡Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒ",
        VISIBLE: "ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ"
    }

    def create_settings(self):
        try:
            res = [Selector(f'set_{num}', name, COLLAPSED, [self.sets[n] for n in set], icon if icon else None) for num, (name, set, icon) in self.buttons.items()]
            return res
        except Exception as e:
            log(f"Failed to create settings: {e}")
            return []

    def on_plugin_load(self):
        # --- hook constructors dynamically ---
        for c in ChatActivityEnterView.getClass().getDeclaredConstructors():
            if len(c.getParameterTypes()) > 0:
                self.hook_method(c, EnterViewHook(self))
        
        # --- hook sendmessageinternal dynamically ---
        for m in ChatActivityEnterView.getClass().getDeclaredMethods():
            if m.getName() == "sendMessageInternal":
                self.hook_method(m, OnSend())

        self.hook_method(ChatActivity.getClass().getDeclaredMethod("updatePagedownButtonsPosition"), OnTranslationCalculation(self))
        self.hook_method(ChatActivityEnterView.getClass().getDeclaredMethod("createRecordCircle"), CreateRecordCircleHook())
        self.hook_method(PeerStoriesView.getClass().getDeclaredMethod("createEnterView"), EnterViewInStoriesHook())
    
    _collapse_states: Dict[int, bool] = {}

    def is_collapsed(self, id) -> bool:
        state = self._collapse_states.get(id, True)
        return state

    def set_collapsed(self, id, value: bool):
        self._collapse_states[id] = value
    
    def update_collapsed(self, id) -> bool:
        val = self.is_collapsed(id)
        self.set_collapsed(id, not val)
        return not val
    
    def get_set(self, id):
        i = self.get_setting(f"set_{id}", COLLAPSED)
        if i == VISIBLE and self.buttons[id][1] == SINGLE_SET:
            return COLLAPSED
        return i

LAST_TEXT = None

class EnterViewInStoriesHook(MethodHook):
    calling = False
    def before_hooked_method(self, param):
        EnterViewInStoriesHook.calling = True
    
    def after_hooked_method(self, param):
        EnterViewInStoriesHook.calling = False

class CreateRecordCircleHook(MethodHook):
    def before_hooked_method(self, param):
        self.cancel = param.thisObject.getRecordCircle() is not None
        
    def after_hooked_method(self, param):
        if self.cancel:
            return
        record_circle =param.thisObject.getRecordCircle()
        if record_circle and EnterViewHook.items_layout:
            record_circle.setTranslationY(record_circle.getTranslationY() - EnterViewHook.items_layout.getMeasuredHeight())

class OnTranslationCalculation(MethodHook):
    def __init__(self, plugin: Plugin):
        OnTranslationCalculation.plugin = plugin
        
    def before_hooked_method(self, param):
        OnTranslationCalculation.hook = self.plugin.hook_method(View.getClass().getDeclaredMethod("getTranslationY"), OnChatActivityEnterViewTranslationCalculation())
    
    def after_hooked_method(self, param):
        self.plugin.unhook_method(self.hook)
        
class OnChatActivityEnterViewTranslationCalculation(MethodHook):
    def after_hooked_method(self, param):
        try:
            if not EnterViewHook.items_layout:
                return
            param.setResult(jfloat(int(param.getResult()) - int(EnterViewHook.items_layout.getMeasuredHeight())))
            OnTranslationCalculation.plugin.unhook_method(OnTranslationCalculation.hook)
        except Exception as e:
            log(e)

class OnSend(MethodHook):
    def before_hooked_method(self, param):
        try:
            messageEditText = get_private_field(param.thisObject, "messageEditText")
            text = None if messageEditText == None else messageEditText.getText()
            if not EnterViewHook.items_layout or text is None or not text.toString().strip():
                return
            global LAST_TEXT
            LAST_TEXT = text
            resend = EnterViewHook.items_layout.findViewWithTag(40)
            resend.setVisibility(View.VISIBLE)
            index = EnterViewHook.items_layout.indexOfChild(resend)
            if (index != -1 and index + 1 < EnterViewHook.items_layout.getChildCount()):
                EnterViewHook.items_layout.getChildAt(index + 1).setVisibility(View.VISIBLE)
        except Exception as e:
            log(f"Failed to update text: {e}")

class EnterViewHook(MethodHook):
    items_layout = None
    def __init__(self, plugin: Plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            if EnterViewInStoriesHook.calling:
                return
            
            self.input_expanded = False
            self.chat_activity_enter_view: ChatActivityEnterView = param.thisObject

            if not get_private_field(param.thisObject, "messageEditText").isEnabled():
                return

            self.ly = ly = LinearLayout(param.args[0])
            ly.setOrientation(LinearLayout.VERTICAL)

            tfc = get_private_field(param.thisObject, "textFieldContainer")
            tfc.getParent().removeView(tfc)
            tfc_wrap = FrameLayout(param.args[0])
            tfc_wrap.addView(tfc)
            ly.addView(tfc_wrap)

            EnterViewHook.items_layout = self.items_layout = items_layout = LinearLayout(param.args[0])
            items_layout.setTag(101010)
            items_layout.setOrientation(LinearLayout.HORIZONTAL)

            items_layout_wrap = HorizontalScrollView(param.args[0])
            items_layout_wrap.addView(items_layout)
            ly.addView(items_layout_wrap, LayoutHelper.createLinear(-1, 36, Gravity.BOTTOM, 8, 0, 8, 0))
            EnterViewHook.items_layout = items_layout
            
            param.thisObject.addView(ly, LayoutHelper.createFrame(-1, -2, Gravity.BOTTOM))

            self._add_new_item(30, "pip_video_expand")
            self._add_new_item(0, "mentionbutton")
            self._add_new_item(10, "msg_text_outlined", [
                "msg_clear",
                self._create_text_icon("B", Typeface.BOLD), 
                self._create_text_icon("I", Typeface.ITALIC),
                self._create_text_icon("M", Typeface.NORMAL), 
                self._create_text_icon("S", Typeface.NORMAL), 
                self._create_text_icon("U", Typeface.NORMAL), 
                "menu_link_create",
                self._create_emoji_icon(5886437972647088483), 
                "msg_spoiler",])
            self._add_new_item(20, "msg_edit", [
                "menu_select_quote",
                "attach_arrow_left",
                "attach_arrow_right",
                "msg_copy",
                self._create_emoji_icon(5877597667231534929)
            ])

            Emoji.loadRecentEmoji()
            recent_emojis = [self._parse_emoji(x) for x in Emoji.recentEmoji.toArray()[:5]]
            if recent_emojis is not None and len(recent_emojis) > 0:
                self._add_new_item(60, "input_smile", [self._create_emoji_icon(emoji_id) for emoji_id in recent_emojis])

            resend = self._add_new_item(40, "msg_retry")
            if resend is not None and LAST_TEXT is None:
                resend.setVisibility(View.GONE)
                index = self.items_layout.indexOfChild(resend)
                if (index != -1 and index + 1 < self.items_layout.getChildCount()):
                    self.items_layout.getChildAt(index + 1).setVisibility(View.GONE)
            self._add_new_item(50, "input_keyboard")

            if self.items_layout.getChildCount() == 0:
                self.items_layout.setVisibility(View.GONE)
            
            self.max_lines = self.chat_activity_enter_view.getEditField().getMaxLines()

        except Exception as e:
            log(e)

    def _parse_emoji(self, str: str) -> Union[int, str]:
        if str.startswith("animated_"):
            return int(str[len("animated_"):])
        return str
    
    def on_item_click(self, view):
        try:
            id: int = view.getTag()
            text_field = self.chat_activity_enter_view.getEditField()
            if not text_field:
                return

            if id % 10 == 0 and Plugin.buttons[id][1] == SET:
                is_visible = self.plugin.update_collapsed(id)
                for i in range(id + 1, id + 10):
                    item = self.items_layout.findViewWithTag(i)
                    if item != None:
                        item.setVisibility(View.GONE if is_visible else View.VISIBLE)
                    else:
                        break
                return
            
            if id >= 0 and id < 10:
                text: SpannableStringBuilder = text_field.getText()
                str_text = text.toString()
                add_text = ""
                if str_text and not str_text.endswith(" "):
                    add_text += " "
                add_text += "@"
                text.append(add_text)
            elif id >= 10 and id < 20:    
                start_selection = text_field.getSelectionStart()
                end_selection = text_field.getSelectionEnd()
                if start_selection == end_selection:
                    return

                text_field.setSelectionOverride(start_selection, end_selection)

                if id == 11:
                    text_field.makeSelectedRegular()
                if id == 12:
                    text_field.makeSelectedBold()
                elif id == 13:
                    text_field.makeSelectedItalic()
                elif id == 14:
                    text_field.makeSelectedMono()
                elif id == 15:
                    text_field.makeSelectedStrike()
                elif id == 16:
                    text_field.makeSelectedUnderline()
                elif id == 17:
                    text_field.makeSelectedUrl()
                elif id == 18:
                    text_field.makeSelectedQuote(True)
                elif id == 19:
                    text_field.makeSelectedSpoiler()
            elif id >= 20 and id < 30:
                if id == 21: text_field.selectAll()
                elif id == 22: text_field.setSelection(0)
                elif id == 23: text_field.setSelection(text_field.getText().length())
                elif id == 24: 
                    start_selection = text_field.getSelectionStart()
                    end_selection = text_field.getSelectionEnd()
                    if start_selection == end_selection:
                        return
                    AndroidUtilities.addToClipboard(text_field.getText().subSequence(start_selection, end_selection).toString())
                    BulletinHelper.show_copied_to_clipboard()
                elif id == 25:
                    context = get_last_fragment().getContext()
                    clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                    if clipboard.hasPrimaryClip():
                        clip_data = clipboard.getPrimaryClip()
                        if clip_data.getItemCount() > 0:
                            pasted_text = clip_data.getItemAt(0).coerceToText(context)
                            if pasted_text:
                                start_selection = text_field.getSelectionStart()
                                end_selection = text_field.getSelectionEnd()
                                text_field.getText().replace(start_selection, end_selection, pasted_text)
                                text_field.setSelection(start_selection + len(pasted_text))
            elif id == 30:
                content_view = self.chat_activity_enter_view.getParent()
                if not self.input_expanded:
                    self.original_height = self.chat_activity_enter_view.getLayoutParams().height
                self.input_expanded = not self.input_expanded
                if content_view:
                    lp = self.chat_activity_enter_view.getLayoutParams()
                    if self.input_expanded:
                        text_field.setMaxLines(2**31-1)
                        lp.height = content_view.getHeight() - AndroidUtilities.getStatusBarHeight(get_last_fragment().getContext()) - self.chat_activity_enter_view.getParentFragment().getActionBar().getCurrentActionBarHeight()
                    else:
                        text_field.setMaxLines(self.max_lines)
                        lp.height = self.original_height
                    self.chat_activity_enter_view.setLayoutParams(lp)
            elif id == 40:
                if LAST_TEXT is None:
                    AndroidUtilities.shakeView(view)
                    return
                text_field.setText(LAST_TEXT)
                text_field.setSelection(text_field.getText().length())
            elif id == 50:
                if self.chat_activity_enter_view.getParentFragment().isKeyboardVisible():
                    AndroidUtilities.hideKeyboard(self.chat_activity_enter_view.getParentFragment().getParentActivity().getCurrentFocus())
                else:
                    self.chat_activity_enter_view.openKeyboard()

                if self.input_expanded:
                    self.on_item_click(self.items_layout.findViewWithTag(30))
            elif id >= 60 and id < 70:
                start_selection = text_field.getSelectionStart()
                end_selection = text_field.getSelectionEnd()

                emoji_data = self._parse_emoji(Emoji.recentEmoji.toArray()[id - 61])
                if isinstance(emoji_data, str):
                    if start_selection == end_selection:
                        text_field.getText().insert(start_selection, emoji_data)
                    else:
                        text_field.getText().replace(start_selection, end_selection, emoji_data)
                else:
                    span = AnimatedEmojiSpan(emoji_data, text_field.getPaint().getFontMetricsInt())
                    text = text_field.getText()
                    text.replace(start_selection, end_selection, "ðŸ˜€")
                    text.setSpan(span, start_selection, start_selection + 2, 33)
                
        except Exception as e:
            log(e)
    
    def _create_text_icon(self, symbol: str, style: int) -> View:
        ic = TextView(get_last_fragment().getContext())
        ic.setText(symbol)
        ic.setTypeface(None, style)
        ic.setTextColor(TelegramUtils.get_color("chat_messagePanelIcons"))
        ic.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM)
        ic.setAutoSizeTextTypeUniformWithConfiguration(
                10,
                100,
                1,
                TypedValue.COMPLEX_UNIT_SP
        )
        ic.setGravity(Gravity.CENTER)
        ic.setScaleX(0.9)
        ic.setScaleY(0.9)
        return ic

    def _create_emoji_icon(self, emoji: Union[int, str]) -> View:    
        ic = self._create_image_view_icon()
        
        if isinstance(emoji, int):
            drawable = AnimatedEmojiDrawable.make(UserConfig.selectedAccount, AnimatedEmojiDrawable.getCacheTypeForEnterView(), emoji)
            drawable.addView(ic)
        else:
            drawable = Emoji.getEmojiDrawable(emoji)
            
        ic.setImageDrawable(drawable) 
        ic.setScaleX(0.85)
        ic.setScaleY(0.85)
        return ic

    def _create_image_view_icon(self) -> BounceableImageView:
        ic = BounceableImageView(self.ly.getContext(), 0.1)
        ic.setColorFilter(PorterDuffColorFilter(TelegramUtils.get_color("chat_messagePanelIcons"), PorterDuff.Mode.MULTIPLY))
        ic.setScaleType(ImageView.ScaleType.CENTER)
        ic.setBackground(Theme.createSelectorDrawable(TelegramUtils.get_color_id("listSelectorSDK21")))
        return ic

    def _add_new_item(self, item_id: int, icon: Union[str,View], sub_items: Optional[List[Union[str, View]]] = None, divider: bool = True):
        set = VISIBLE if item_id % 10 != 0 else self.plugin.get_set(item_id)
        collapsed = False if set == VISIBLE else self.plugin.is_collapsed(item_id)
        ic = None

        if set == HIDDEN:
            return ic
        
        if set != VISIBLE or (item_id % 10 != 0):
            if isinstance(icon, str):
                ic = self._create_image_view_icon()
                ic.setImageResource(TelegramUtils.get_icon_id(icon))
            else:
                ic = icon
            ic.setOnClickListener(OnClickListener(self.on_item_click))
            ic.setTag(item_id)
            self.items_layout.addView(ic, LayoutHelper.createLinear(36, 36))

        if sub_items is not None:
            for i, sub_item in enumerate(sub_items):
                new_item = self._add_new_item(item_id + i + 1, sub_item, None, False)
                if new_item:
                    if collapsed:
                        new_item.setVisibility(View.GONE)

        if divider:
            divider_view = View(self.items_layout.getContext())
            divider_view.setBackgroundColor(TelegramUtils.get_color("divider"))
            self.items_layout.addView(divider_view, LayoutHelper.createLinear(2, -1, Gravity.CENTER_VERTICAL, 4, 8, 4, 8))
        
        return ic

class OnClickListener(dynamic_proxy(View.OnClickListener)):
    def __init__(self, fn: Callable[[View], None]):
        super().__init__()
        self.fn = fn
    
    def onClick(self, view):
        self.fn(view)

class TelegramUtils:
    @staticmethod
    def get_icon_id(name: str) -> int:
        context = get_last_fragment().getContext()
        return context.getResources().getIdentifier(name, "drawable", context.getPackageName())

    _colors_key_map: Dict[str, int] = None

    @classmethod
    def _init_colors_key_map(cls):
        if cls._colors_key_map is None:
            method = ThemeColors.getClass().getDeclaredMethod("createColorKeysStringMap")
            method.setAccessible(True)
            cls._colors_key_map = method.invoke(None)
    
    @classmethod
    def get_color_id(cls, name: str) -> int:
        cls._init_colors_key_map()
        return cls._colors_key_map.get(name)
    
    @classmethod
    def get_color(cls, name: str) -> int:
        return Theme.getColor(cls.get_color_id(name))

class RunnableFactory(dynamic_proxy(Runnable)):
    def __init__(self, fn: Callable):
        super().__init__()
        self.fn = fn
    
    def run(self):
        self.fn()
